# 📝 LeetCode 1. Two Sum (심화 정리)

## 1. 문제 개요
배열(`nums`) 안의 두 수를 더해서 목표값(`target`)이 되는 **두 수의 인덱스**를 찾는 문제입니다.
- **제약 조건:** 정확히 하나의 정답만 존재하며, 같은 요소를 두 번 사용할 수 없습니다.
- **목표:** 시간 복잡도를 $O(n^2)$보다 빠르게 최적화해야 합니다.

---

## 2. 풀이 방법 1: Brute Force (완전 탐색)
제공해주신 코드의 접근 방식입니다. 현재 숫자와 더해서 `target`이 되는 숫자가 **나머지 리스트**에 있는지 확인합니다.

### 💡 핵심 논리
- 반복문을 돌면서 필요한 차액(`diff = target - nums[i]`)을 계산합니다.
- `in` 연산자를 사용해 나머지 리스트(`nums[i+1:]`)를 **선형 탐색**합니다.

### 📉 복잡도 분석
- **시간 복잡도:** $O(n^2)$
  - `for` 루프가 $n$번 돕니다.
  - 내부의 `diff in new` 연산과 슬라이싱은 리스트 전체를 훑어야 하므로 평균 $O(n)$이 소요됩니다.
  - 따라서 전체는 $n \times n = O(n^2)$가 됩니다. (입력 크기가 커지면 매우 느려짐)

---

## 3. 풀이 방법 2: Hash Map (Dictionary) 최적화

데이터를 저장할 때 '값'을 키(Key)로, '인덱스'를 값(Value)으로 저장하여 검색 속도를 획기적으로 줄이는 방법입니다.

### 💡 핵심 논리: 공간과 시간을 교환 (Space-Time Tradeoff)
리스트를 매번 다시 훑는 대신, **"내가 지금까지 본 숫자와 인덱스"**를 딕셔너리에 기록해둡니다.

1. 현재 숫자(`num`)를 확인합니다.
2. `target - num` (필요한 짝꿍 숫자)이 딕셔너리에 있는지 확인합니다.
   - **있다면?** 바로 정답을 반환합니다. (짝꿍의 인덱스, 현재 인덱스)
   - **없다면?** 현재 숫자와 인덱스를 딕셔너리에 저장하고 다음으로 넘어갑니다.

### 📐 복잡도 분석
- **시간 복잡도:** $O(n)$
  - 리스트를 한 번만 순회합니다 ($n$).
  - 해시 맵(딕셔너리)에서의 조회(`in`)는 평균적으로 $O(1)$입니다.
- **공간 복잡도:** $O(n)$
  - 최악의 경우, 리스트의 모든 요소를 딕셔너리에 저장해야 합니다.

### 💻 코드 (Python)

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        # 값을 Key로, 인덱스를 Value로 저장할 딕셔너리
        memo = {}
        
        for i, num in enumerate(nums):
            # 필요한 짝꿍 숫자 계산
            needed = target - num
            
            # 짝꿍이 이미 딕셔너리에 있다면 즉시 반환 (순서: 저장된 인덱스, 현재 인덱스)
            if needed in memo:
                return [memo[needed], i]
            
            # 짝꿍이 없다면 현재 숫자를 딕셔너리에 등록
            memo[num] = i
            
        return []

```

---

## 4. 요약 비교

| 방식 | 시간 복잡도 | 공간 복잡도 | 특징 |
| --- | --- | --- | --- |
| **List Slicing (작성하신 코드)** |  |  | 코드가 직관적이나 데이터가 많으면 느림 |
| **Hash Map (최적화)** |  |  | 추가 메모리를 사용해 속도를 비약적으로 향상 |

