# 📝 LeetCode 217. Contains Duplicate (심화 정리)

## 1. 문제 개요
정수 배열 `nums`가 주어졌을 때, **중복된 값이 하나라도 있으면 `true`**, 모든 요소가 서로 다르면 `false`를 반환하는 문제입니다.

- **입력:** 정수 배열 (`[1, 2, 3, 1]`)
- **출력:** Boolean (`true` or `false`)
- **제약 조건:** $1 \le nums.length \le 10^5$ (데이터가 꽤 많으므로 $O(N^2)$ 풀이는 시간 초과 가능성 있음)

---

## 2. 작성하신 풀이: Set 길이 비교
파이썬의 집합(Set)은 **중복을 허용하지 않는다**는 성질을 이용한 직관적인 방법입니다.

### 💡 핵심 논리
1. 원본 리스트를 `set`으로 변환하면 중복된 요소가 자동으로 제거됩니다.
2. 만약 중복이 있었다면, `len(set)`이 `len(list)`보다 작아집니다.
3. 두 길이를 비교하여 다르다면 `True`를 반환합니다.

### 💻 코드
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        # 중복 제거 후 길이가 줄어들었다면 중복이 있었다는 뜻
        return len(set(nums)) != len(nums)
```

### 📊 복잡도 분석

* **시간 복잡도:** 
* `set()`을 생성하는 과정에서 배열의 모든 요소를 한 번씩 읽어야 합니다.


* **공간 복잡도:** 
* 최악의 경우(중복이 없을 때), 배열과 거의 동일한 크기의 메모리 공간이 필요합니다.


---

## 3. 더 효율적인 방법: Hash Set (Early Exit)

작성하신 코드는 매우 훌륭하지만, **중복이 배열의 맨 앞에 있더라도** 무조건 리스트 전체를 `set`으로 변환한 뒤 길이를 비교해야 한다는 특징이 있습니다.

만약 `[1, 1, 2, 3, ..., 10000]` 처럼 **시작하자마자 중복이 발견되는 경우**, 굳이 끝까지 확인할 필요가 없겠죠? 이를 위해 **조기 종료(Early Exit)** 전략을 사용할 수 있습니다.

### 💡 핵심 논리

* 빈 `set`을 하나 만듭니다.
* 배열을 순회하면서 요소를 하나씩 꺼냅니다.
* **"이 숫자가 `set`에 이미 들어있는가?"**를 확인합니다.
* 있다면? → **즉시 `True` 반환 후 종료** (더 볼 필요 없음)
* 없다면? → `set`에 추가하고 계속 진행



### 💻 개선된 코드

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            # 이미 본 숫자라면 바로 True 반환 (조기 종료)
            if num in seen:
                return True
            seen.add(num)
        
        # 끝까지 돌았는데 중복이 없었다면
        return False

```

### ⚖️ 비교 및 결론

| 구분 | 작성하신 풀이 (Length Check) | 개선된 풀이 (Iterative Check) |
| --- | --- | --- |
| **코드 간결성** | ⭐⭐⭐⭐⭐ (한 줄로 매우 깔끔) | ⭐⭐⭐ (약간의 로직 필요) |
| **최악의 시간** |  (전체 스캔) |  (전체 스캔) |
| **최선의 시간** | **** (항상 전체를 변환해야 함) | **** (첫 두 개가 중복이면 바로 종료) |

> **💡 결론:**
> * **코딩 테스트/인터뷰:** "중복이 발견되면 즉시 멈추는 것이 효율적이지 않을까요?"라는 질문을 받을 수 있으므로 **3번 방법(개선된 풀이)**을 알고 계시는 것이 좋습니다.
> * **실무/빠른 구현:** 파이썬 내부 최적화(C언어 레벨) 덕분에 작성하신 `len(set(nums))` 방식도 실제 실행 속도는 매우 빠르며 가독성이 좋아 자주 사용됩니다.

---

## 4. (참고) 공간 복잡도 최적화: 정렬 (Sorting)

만약 **"메모리를 $O(N)$만큼 쓰지 말고, 공간을 절약해서 풀어보세요"**라는 제약이 있다면 정렬을 사용합니다.

* **방법:** 배열을 정렬(`sort`)한 뒤, 인접한 두 요소(`i`와 `i+1`)가 같은지 확인합니다.
* **복잡도:** 시간  / 공간  (단, 원본 배열을 변형함)

```python
nums.sort()
for i in range(len(nums) - 1):
    if nums[i] == nums[i+1]:
        return True

```
